// Generated by CoffeeScript 1.10.0
(function() {
  var Notes, colors, fs;

  fs = require('fs');

  colors = require('colors');

  Notes = (function() {
    var eachLineIn, filesUnderDirectory;

    Notes.patterns = {
      todo: {
        regexp: /^.*(#|\/\/|\/\*)\s*TODO\W*/,
        label: "✓ TODO".underline.magenta
      },
      note: {
        regexp: /^.*(#|\/\/|\/\*)\s*NOTE\W*/,
        label: "✐ NOTE".underline.blue
      },
      optimize: {
        regexp: /^.*(#|\/\/|\/\*)\s*OPTIMIZE\W*/,
        label: "↘ OPTIMIZE".underline.yellow
      },
      fixme: {
        regexp: /^.*(#|\/\/|\/\*)\s*FIXME\W*/,
        label: "☂ FIXME".underline.red
      }
    };

    Notes.filterExtensions = ["\\.jpg", "\\.jpeg", "\\.mov", "\\.mp3", "\\.gif", "\\.png", "\\.log", "\\.bin", "\\.psd", "\\.swf", "\\.fla", "\\.ico"];

    Notes.filterDirectories = ["node_modules", "components", "bower_components"];

    Notes.skipHidden = true;

    Notes.concurrentFiles = 30;

    function Notes(rootDir) {
      this.rootDir = rootDir;
      if (!this.rootDir) {
        throw "Root directory is required.";
      }
    }

    Notes.prototype.annotate = function() {
      var concurrency, files, output, run;
      files = [];
      filesUnderDirectory(this.rootDir, function(file) {
        return files.push(file);
      });
      concurrency = 0;
      output = {};
      run = function() {
        var file, onCompletion, onLine, results;
        results = [];
        while (files.length > 0 && concurrency < Notes.concurrentFiles) {
          onLine = function(line, lineNum, filePath) {
            var j, key, len, lineNumStr, n, pattern, ref, ref1, results1, spaces;
            ref = Notes.patterns;
            results1 = [];
            for (key in ref) {
              pattern = ref[key];
              if (line.match(pattern.regexp) != null) {
                if (output[filePath] == null) {
                  output[filePath] = ("* " + (filePath.replace('//', '/')) + "\n").green;
                }
                line = line.replace(pattern.regexp, '');
                spaces = '     ';
                ref1 = (lineNum + 1).toString();
                for (j = 0, len = ref1.length; j < len; j++) {
                  n = ref1[j];
                  spaces = spaces.substring(0, spaces.length - 1);
                }
                lineNumStr = ("Line " + lineNum + ":").grey;
                results1.push(output[filePath] += "  " + lineNumStr + spaces + pattern.label + " " + line + "\n");
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          };
          onCompletion = function(filePath) {
            if (output[filePath] != null) {
              console.log(output[filePath]);
            }
            concurrency--;
            return run();
          };
          file = files.shift();
          eachLineIn(file, onLine, onCompletion);
          results.push(concurrency++);
        }
        return results;
      };
      return run();
    };

    filesUnderDirectory = function(dir, fileCallback) {
      var error, error1, f, files, filter, j, len, results;
      try {
        files = fs.readdirSync(dir);
        if (files != null) {
          if (Notes.skipHidden) {
            files = (function() {
              var j, len, results;
              results = [];
              for (j = 0, len = files.length; j < len; j++) {
                f = files[j];
                if (!f.match(/^\./)) {
                  results.push(f);
                }
              }
              return results;
            })();
          }
          files = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = files.length; j < len; j++) {
              f = files[j];
              if (Notes.filterDirectories.indexOf(f) < 0) {
                results.push(f);
              }
            }
            return results;
          })();
          results = [];
          for (j = 0, len = files.length; j < len; j++) {
            f = files[j];
            results.push(filesUnderDirectory(dir + "/" + f, fileCallback));
          }
          return results;
        }
      } catch (error1) {
        error = error1;
        if (error.code === "ENOTDIR") {
          filter = RegExp("(" + (Notes.filterExtensions.join('|')) + ")$");
          if (!dir.match(filter)) {
            return fileCallback(dir);
          }
        } else if (error.code === "ELOOP") {
          return console.log(error + "... continuing.");
        } else {
          throw error;
        }
      }
    };

    eachLineIn = function(filePath, onLine, onCompletion) {
      return fs.readFile(filePath, function(err, data) {
        var i, j, len, line, lines;
        if (err != null) {
          throw err;
        }
        lines = data.toString('utf-8').split("\n");
        for (i = j = 0, len = lines.length; j < len; i = ++j) {
          line = lines[i];
          onLine(line, i + 1, filePath);
        }
        return onCompletion(filePath);
      });
    };

    return Notes;

  })();

  module.exports = Notes;

}).call(this);
